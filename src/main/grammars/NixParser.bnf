{
  parserClass="org.nixdea.parser.NixParser"
  parserUtilClass="org.nixdea.parser.NixParserUtil"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  psiClassPrefix="Nix"
  psiImplClassSuffix="Impl"
  psiPackage="org.nixdea.psi"
  psiImplPackage="org.nixdea.psi.impl"

  elementTypeHolderClass="org.nixdea.psi.NixTypes"
  elementTypeClass="org.nixdea.psi.NixElementType"
  tokenTypeClass="org.nixdea.psi.NixTokenType"

  psiImplUtilClass="org.nixdea.parser.NixParserUtil"

  parserImports=[
    "static com.intellij.psi.TokenType.WHITE_SPACE"
    "static com.intellij.lang.parser.GeneratedParserUtilBase.*"
  ]

  generate=[visitorValue="T"]
  tokens = [
    space='regexp:\s+'
    comment='regexp:#.*'

    ASSIGN = '='
    LPAREN = '('
    RPAREN = ')'
    LCURLY = '{'
    RCURLY = '}'
    LBRAC = '['
    RBRAC = ']'
    DOLLAR_CURLY = '${'
    DOLLAR = '$'
    IS = '?'
    NAMED = '@'
    COLON = ':'
    SEMI = ';'
    AND = '&&'
    OR = '||'
    NOT = '!'
    EQ = '=='
    NEQ = '!='
    LEQ = '<='
    GEQ = '>='
    LT = '<'
    GT = '>'
    PLUS = '+'
    MINUS = '-'
    DIVIDE = '/'
    TIMES = '*'
    CONCAT = '++'
    DOT = '.'
    COMMA = ','
    IMPL = '->'
    UPDATE = '//'

    ASSERT = 'assert'
    IF = 'if'
    ELSE = 'else'
    THEN = 'then'
    WITH = 'with'
    LET = 'let'
    IN = 'in'
    REC = 'rec'
    OR_KW = 'or'
    ELLIPSIS = '...'
    INHERIT = 'inherit'
    IMPORT = 'import'

    SCOMMENT = 'regexp:#[^\r\n]*'
    MCOMMENT = 'regexp:/\*([^*]|\*[^/])*\*/'

    INT = "regexp:[0-9]+"
    BOOL = "regexp:(true|false)"
    ID = "regexp:[a-zA-Z][a-zA-Z_0-9'-]*"

    PATH = "regexp:[a-zA-Z0-9._\-+]*(/[a-zA-Z0-9._\-+]+)+"
    SPATH = "regexp:<[a-zA-Z0-9._\-+]+(/[a-zA-Z0-9._\-+]+)*>"
    HPATH = "regexp:~(/[a-zA-Z0-9._\-+]+)+"
    URI = "regexp:[a-zA-Z][a-zA-Z0-9+\-.]*:[a-zA-Z0-9%/?:@&=+$,\-_.!~*']+"

    QUOT_OPEN = "\""
    QUOT_CLOSE = "\""

    IND_STRING_OPEN = "''"
    IND_STRING_CLOSE = "''"
  ]

  extends(".*_op_expr")=op_expr
}

nixFile ::= !<<eof>> expr

expr ::= if_expr
       | with_expr
       | assert_expr
       | let_expr
       | op_expr

if_expr ::= IF expr THEN expr ELSE expr { extends="expr" pin=1 }
with_expr ::= WITH expr SEMI expr { extends="expr" pin=1 }
assert_expr ::= ASSERT expr SEMI expr { extends="expr" pin=1 }
let_expr ::= LET binds IN expr { extends="expr" pin=1 }

lambda ::= param COLON expr { extends="op_expr" pin=2 }
param ::= param_starting_with_set | param_starting_with_id
param_starting_with_set ::= param_set [NAMED ID] { pin=1 }
param_starting_with_id ::= ID [NAMED param_set] { pin=1 }
param_set ::= LCURLY param_set_attrs ELLIPSIS? RCURLY { pin=1 }
private param_set_attrs ::= param_set_attrs_with_recover*

private param_set_attrs_with_recover ::= !(COLON | RCURLY | ELLIPSIS | <<eof>>) param_set_attr { pin=1 recoverWhile=param_recover }
// the part in parens means: it ends with a comma, or, if it doesn't, the next token must be a right curly brace
param_set_attr ::= ID with_default? (COMMA | &RCURLY)
private with_default ::= IS expr { pin=1 }
private param_recover ::= !(RCURLY | ELLIPSIS | ID | COLON)

op_expr ::= lambda
          | literal
          | paren_op_expr
          | implies_op_expr
          | or_op_expr
          | and_op_expr
          | eq_group
          | comp_group
          | set_union_op_expr
          | bool_negation_op_expr
          | add_group
          | mul_group
          | list_concat_op_expr
          | attr_test_op_expr
          | arith_negation_op_expr
          | call_op_expr
          | import_op_expr
          | select_op_expr
          { extends="expr" }

private mul_group ::= mul_op_expr | div_op_expr
private add_group ::= add_op_expr | sub_op_expr
private comp_group ::= lt_op_expr | gt_op_expr | lte_op_expr | gte_op_expr
private eq_group ::= eq_op_expr | neq_op_expr

select_op_expr ::= op_expr (DOT attr)+ [ OR_KW (paren_op_expr | select_op_expr | literal) ]
import_op_expr ::= IMPORT op_expr { pin=1 }
call_op_expr ::= op_expr (paren_op_expr | select_op_expr | literal)
arith_negation_op_expr ::= MINUS op_expr
attr_test_op_expr ::= op_expr IS attr_path { pin=2 }
list_concat_op_expr ::= op_expr CONCAT op_expr { rightAssociative=true }

mul_op_expr ::= op_expr TIMES op_expr { pin=2 }
div_op_expr ::= op_expr DIVIDE op_expr { pin=2 }

add_op_expr ::= op_expr PLUS op_expr { pin=2 }
sub_op_expr ::= op_expr MINUS op_expr { pin=2 }

bool_negation_op_expr ::= NOT op_expr { pin=1 }
set_union_op_expr ::= op_expr UPDATE op_expr { pin=2 rightAssociative=true }

lt_op_expr ::= op_expr LT op_expr { pin=2 }
gt_op_expr ::= op_expr GT op_expr { pin=2 }
lte_op_expr ::= op_expr LEQ op_expr { pin=2 }
gte_op_expr ::= op_expr GEQ op_expr { pin=2 }

eq_op_expr ::= op_expr EQ op_expr { pin=2 }
neq_op_expr ::= op_expr NEQ op_expr { pin=2 }

and_op_expr ::= op_expr AND op_expr { pin=2 }
or_op_expr ::= op_expr OR op_expr { pin=2 }
implies_op_expr ::= op_expr IMPL op_expr { pin=2 }
paren_op_expr ::= LPAREN expr RPAREN { pin=1 }

attr ::= ID | antiquotation | string

literal ::= ID
          | INT
          | BOOL
          | list
          | set
          | path_lit
          | string
          { extends="op_expr" }

path_lit ::= PATH | SPATH | HPATH { extends="literal" }
list ::= LBRAC expr* RBRAC { extends="literal" pin=1}
set ::= rec_set | simple_set { extends="literal" }
rec_set ::= REC simple_set { pin=1 extends="set" }
simple_set ::= LCURLY binds? RCURLY !COLON { pin=1 extends="set" }

string ::= simple_string | ind_string | uri_string { extends="literal"}
uri_string ::= URI { extends="string" }
simple_string ::= QUOT_OPEN (STR | antiquotation)* QUOT_CLOSE { pin=1 extends="string" }
ind_string ::= IND_STRING_OPEN (IND_STR | antiquotation)* IND_STRING_CLOSE { pin=1 extends="string" }
antiquotation ::= DOLLAR_CURLY expr RCURLY { pin=1 }

binds ::= !IN binding+
binding ::= (inherit_attrs | attr_assign) { recoverWhile="binding_recover" }
inherit_attrs ::= INHERIT (LPAREN expr RPAREN)? attr* SEMI { extends="binding" pin=1 }
attr_path ::= attr (DOT attr)*
attr_assign ::= attr_path ASSIGN expr SEMI { extends="binding" pin=1 }
private binding_recover ::= !((attr_path ASSIGN)|INHERIT|IN|RCURLY)
