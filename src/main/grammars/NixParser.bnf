{
  parserClass="org.nixdea.parser.NixParser"
  parserUtilClass="org.nixdea.parser.NixParserUtil"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  extendedPin=false
  psiClassPrefix="Nix"
  psiImplClassSuffix="Impl"
  psiPackage="org.nixdea.psi"
  psiImplPackage="org.nixdea.psi.impl"

  elementTypeHolderClass="org.nixdea.psi.NixTypes"
  elementTypeClass="org.nixdea.psi.NixElementType"
  tokenTypeClass="org.nixdea.psi.NixTokenType"

  psiImplUtilClass="org.nixdea.parser.NixParserUtil"

  parserImports=[
    "static com.intellij.psi.TokenType.WHITE_SPACE"
    "static com.intellij.lang.parser.GeneratedParserUtilBase.*"
  ]

  generate=[tokenAccessors="yes"]
  tokens = [
    space='regexp:\s+'
    comment='regexp:#.*'

    ASSIGN = '='
    LPAREN = '('
    RPAREN = ')'
    LCURLY = '{'
    RCURLY = '}'
    LBRAC = '['
    RBRAC = ']'
    DOLLAR_CURLY = '${'
    DOLLAR = '$'
    IS = '?'
    NAMED = '@'
    COLON = ':'
    SEMI = ';'
    AND = '&&'
    OR = '||'
    NOT = '!'
    EQ = '=='
    NEQ = '!='
    LEQ = '<='
    GEQ = '>='
    LT = '<'
    GT = '>'
    PLUS = '+'
    MINUS = '-'
    DIVIDE = '/'
    TIMES = '*'
    CONCAT = '++'
    DOT = '.'
    COMMA = ','
    IMPL = '->'
    UPDATE = '//'

    ASSERT = 'assert'
    IF = 'if'
    ELSE = 'else'
    THEN = 'then'
    WITH = 'with'
    LET = 'let'
    IN = 'in'
    REC = 'rec'
    OR_KW = 'or'
    ELLIPSIS = '...'
    INHERIT = 'inherit'
    IMPORT = 'import'

    SCOMMENT = 'regexp:#[^\r\n]*'
    MCOMMENT = 'regexp:/\*([^*]|\*[^/])*\*/'

    INT = "regexp:[0-9]+"
    BOOL = "regexp:(true|false)"
    ID = "regexp:[a-zA-Z][a-zA-Z_0-9'-]*"

    PATH = "regexp:[a-zA-Z0-9._\-+]*(/[a-zA-Z0-9._\-+]+)+"
    SPATH = "regexp:<[a-zA-Z0-9._\-+]+(/[a-zA-Z0-9._\-+]+)*>"
    HPATH = "regexp:~(/[a-zA-Z0-9._\-+]+)+"
    URI = "regexp:[a-zA-Z][a-zA-Z0-9+\-.]*:[a-zA-Z0-9%/?:@&=+$,\-_.!~*']+"

    QUOT_OPEN = "\""
    QUOT_CLOSE = "\""

    IND_STRING_OPEN = "''"
    IND_STRING_CLOSE = "''"
  ]

  extends(".*_op_expr")=op_expr
}

nixFile ::= expr

expr ::= if_expr
       | with_expr
       | assert_expr
       | let_expr
       | op_expr

if_expr ::= IF expr THEN expr ELSE expr { extends="expr" pin=1 }
with_expr ::= WITH expr SEMI expr { extends="expr" pin=1 }
assert_expr ::= ASSERT op_expr SEMI expr { extends="expr" pin=1 }
let_expr ::= LET binds IN expr { extends="expr" pin=1 }

lambda ::= param COLON expr { extends="op_expr" pin=2 }
param ::= (ID NAMED param_set | param_set NAMED ID | param_set | ID)
param_set ::= param_set_strict | param_set_ellipsis
private param_set_strict ::= LCURLY (param_set_attrs COMMA?)? RCURLY { pin=1 }
private param_set_ellipsis ::= LCURLY (param_set_attrs COMMA)? ELLIPSIS RCURLY { pin=1 }
private param_set_attrs ::= param_default (COMMA param_default)*

private param_default ::= ID [IS expr]

op_expr ::= lambda
          | literal
          | paren_op_expr
          | implies_op_expr
          | or_op_expr
          | and_op_expr
          | eq_group
          | comp_group
          | set_union_op_expr
          | bool_negation_op_expr
          | add_group
          | mul_group
          | list_concat_op_expr
          | attr_test_op_expr
          | arith_negation_op_expr
          | call_op_expr
          | import_op_expr
          | select_op_expr
          { extends="expr" }

private mul_group ::= mul_op_expr | div_op_expr
private add_group ::= add_op_expr | sub_op_expr
private comp_group ::= lt_op_expr | gt_op_expr | lte_op_expr | gte_op_expr
private eq_group ::= eq_op_expr | neq_op_expr

select_op_expr ::= op_expr (DOT attr)+ [ OR_KW (paren_op_expr | select_op_expr | literal) ]
import_op_expr ::= IMPORT op_expr
call_op_expr ::= op_expr (paren_op_expr | select_op_expr | literal)
arith_negation_op_expr ::= MINUS op_expr
attr_test_op_expr ::= op_expr IS attr (DOT attr)*
list_concat_op_expr ::= op_expr CONCAT op_expr { rightAssociative=true }

mul_op_expr ::= op_expr TIMES op_expr
div_op_expr ::= op_expr DIVIDE op_expr

add_op_expr ::= op_expr PLUS op_expr
sub_op_expr ::= op_expr MINUS op_expr

bool_negation_op_expr ::= NOT op_expr
set_union_op_expr ::= op_expr UPDATE op_expr { rightAssociative=true }

lt_op_expr ::= op_expr LT op_expr
gt_op_expr ::= op_expr GT op_expr
lte_op_expr ::= op_expr LEQ op_expr
gte_op_expr ::= op_expr GEQ op_expr

eq_op_expr ::= op_expr EQ op_expr
neq_op_expr ::= op_expr NEQ op_expr

and_op_expr ::= op_expr AND op_expr
or_op_expr ::= op_expr OR op_expr
implies_op_expr ::= op_expr IMPL op_expr
paren_op_expr ::= LPAREN expr RPAREN

attr ::= ID | DOLLAR_CURLY expr RCURLY | string

literal ::= ID | INT | BOOL | list | set | path_lit | string { extends="op_expr" }

list ::= LBRAC expr* RBRAC { extends="literal" }
set ::= REC? LCURLY binds? RCURLY { extends="literal" pin=2 }
path_lit ::= PATH | SPATH | HPATH { extends="literal" }

string ::= simple_string | ind_string | uri_string { extends="literal"}
uri_string ::= URI { extends="string" }
simple_string ::= QUOT_OPEN (STR | antiquotation)* QUOT_CLOSE { extends="string" }
ind_string ::= IND_STRING_OPEN (IND_STR | antiquotation)* IND_STRING_CLOSE { extends="string" }
antiquotation ::= DOLLAR_CURLY expr RCURLY

binds ::= binding+

binding ::= (inherit_attrs | attr_assign) SEMI
inherit_attrs ::= INHERIT (LPAREN expr RPAREN)? attr* { extends="binding" }
attr_assign ::= attr (DOT attr)* ASSIGN expr { extends="binding" }
